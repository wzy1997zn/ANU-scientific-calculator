package au.edu.anu.scientificcalculator.parser;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;

/**
 * Function Expression
 * with useful methods to manage a function expression.
 * just like f(x_1) = 2 * x_1
 * Should be generated by a FunctionParser
 */
public class FunctionExp extends Exp {
    private VarExp[] _vars; // saving variable expressions so this class can manage them.
    private int varSize; // the amount of different variables
    private Exp _exp; // the real expression

    FunctionExp(List<VarExp> vars, Exp exp) {
        _vars = new VarExp[vars.size()];
        _vars = vars.toArray(_vars);
        _exp = exp;
        setVarSize();
    }

    /**
     * showing the function with the function head
     * @return the function with the function head
     */
    @Override
    public String show() {
        String varsString = "";
        for (VarExp var: _vars) {
            varsString += (var.show() + ",");
        }
        return "f(" + varsString + ")= " + _exp.show();
    }

    @Override
    public double evaluate() {
        return _exp.evaluate(); // evaluate the real expression
    }

    @Override
    public boolean checkTrigonometric() {
        return _exp.checkTrigonometric();
    }

    public int getSizeOfVariable() {
        return varSize;
    }

    /**
     * var size should not be set by other object so it is private and just decided by the var array.
     */
    private void setVarSize() {
        Set<Integer> indexs = new HashSet<>();
        for (VarExp var: _vars) {
            indexs.add(var.get_index());
        }
        varSize = indexs.size();
    }

    /**
     * get all different var's values like
     * @return {x_1, x_2, ...}
     */
    public double[] getVariableValues() {
        double[] values = new double[getSizeOfVariable()];
        for (int i = 0; i < getSizeOfVariable(); i++) {
            for (VarExp var: _vars) {
                if (var.get_index()-1 == i) {
                    values[i] = var.getValue();
                    break;
                }
            }
        }
        return values;
    }

    /**
     * set all values of vars with a double array like
     * @param values {x_1, x_2, ...}
     */
    public void setVaribleValues(double[] values) {
        if (values.length != getSizeOfVariable()) {
            System.err.println("Wrong size of variables");
            return;
        }
        for (VarExp var: _vars) {
            var.setValue(values[var.get_index()-1]);
        }
    }

    /**
     * A much easier function to get useful array of Y
     * @param beginX start of X
     * @param length the amount of needed Y
     * @return the Y array
     */
    public float[] getArrayOfY(double beginX, int length) {
        boolean hasTri = checkTrigonometric();

        float[] xArray = new float[length];
        float[] yArray = new float[length];
        for (int i = 0; i < length; i++) {
            xArray[i] = (float)( beginX + i * 0.001);
            if (hasTri) {
                xArray[i] = (float)Math.toDegrees(xArray[i]);
            }
            double[] curX = {xArray[i]};
            this.setVaribleValues(curX);
            yArray[i] = (float) this.evaluate();
        }
        return yArray;
    }
}
